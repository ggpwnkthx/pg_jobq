/*
  =====================================================================
  10_jobq_types_and_table.sql – Core jobq types, table, and timestamp trigger

  Run as:
    - Any login that is a member of jobq_worker, e.g.:
        GRANT jobq_worker TO <admin_role>;
    - This script will SET ROLE jobq_worker.

  Assumptions (from 00_admin_bootstrap.sql):
    - Roles jobq_worker, jobq_reader, jobq_client, jobq_reporting, jobq_ops exist
    - jobq schema exists (owner will be aligned to jobq_worker by security script if needed)
    - azure_storage extension exists in this DB (for exec_readonly_to_blob in 11_jobq_*)
      though this script itself does not call azure_storage.

  This script:
    - Defines the jobq.job_status enum
    - Creates the jobq.jobs table and updated_at trigger function
    - Adds indexes and backfills columns/constraints for older deployments
    - Is designed to be re-runnable (IF NOT EXISTS, CREATE OR REPLACE, etc.)
  =====================================================================
*/

SET ROLE jobq_worker;

------------------------------
-- 1. Job status enum type
------------------------------

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_type t
    JOIN pg_namespace n ON n.oid = t.typnamespace
    WHERE t.typname = 'job_status'
      AND n.nspname = 'jobq'
  ) THEN
    CREATE TYPE jobq.job_status AS ENUM (
      'pending',
      'running',
      'succeeded',
      'failed',
      'cancelled'
    );
  END IF;
END;
$$ LANGUAGE plpgsql;

------------------------------
-- 2. Jobs table – core job metadata and execution state
------------------------------

CREATE TABLE IF NOT EXISTS jobq.jobs (
    job_id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT now(),

    status              jobq.job_status NOT NULL DEFAULT 'pending',
    scheduled_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
    started_at          TIMESTAMPTZ,
    finished_at         TIMESTAMPTZ,

    -- SQL statement to execute; jobq.enqueue() enforces read-only SELECT/WITH.
    query_sql           TEXT NOT NULL,

    -- Azure Storage destination (see azure_storage.account_add() / blob_put()).
    --   storage_account: logical account name registered with azure_storage.
    --   storage_container: target container within that account.
    --   result_blob_path: populated by the worker on success.
    storage_account     TEXT NOT NULL,
    storage_container   TEXT NOT NULL,
    result_blob_path    TEXT,

    -- Retry & diagnostics.
    max_attempts        INTEGER NOT NULL DEFAULT 3,
    attempt_count       INTEGER NOT NULL DEFAULT 0,
    last_error          TEXT,

    -- Scheduling & metadata.
    priority            INTEGER NOT NULL DEFAULT 0,
    correlation_id      TEXT,
    run_by              TEXT,

    -- Monitoring / execution control.
    --   backend_pid: backend currently running this job (if any).
    --   max_runtime: per-job statement timeout; enforced by jobq.runner().
    backend_pid         INTEGER,
    max_runtime         INTERVAL NOT NULL DEFAULT interval '30 minutes',

    -- Basic sanity guards.
    CONSTRAINT jobq_jobs_max_attempts_chk
      CHECK (max_attempts >= 1),
    CONSTRAINT jobq_jobs_max_runtime_chk
      CHECK (max_runtime > interval '0 seconds'),
    CONSTRAINT jobq_jobs_priority_chk
      CHECK (priority BETWEEN -1000 AND 1000)
);

-- Backfill columns for older deployments (safe no-op on new setups).
ALTER TABLE jobq.jobs
  ADD COLUMN IF NOT EXISTS backend_pid INTEGER;

ALTER TABLE jobq.jobs
  ADD COLUMN IF NOT EXISTS max_runtime INTERVAL NOT NULL DEFAULT interval '30 minutes';

-- Backfill constraints for older deployments (safe no-op on new setups).
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'jobq_jobs_max_attempts_chk'
      AND conrelid = 'jobq.jobs'::regclass
  ) THEN
    ALTER TABLE jobq.jobs
      ADD CONSTRAINT jobq_jobs_max_attempts_chk
      CHECK (max_attempts >= 1);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'jobq_jobs_max_runtime_chk'
      AND conrelid = 'jobq.jobs'::regclass
  ) THEN
    ALTER TABLE jobq.jobs
      ADD CONSTRAINT jobq_jobs_max_runtime_chk
      CHECK (max_runtime > interval '0 seconds');
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'jobq_jobs_priority_chk'
      AND conrelid = 'jobq.jobs'::regclass
  ) THEN
    ALTER TABLE jobq.jobs
      ADD CONSTRAINT jobq_jobs_priority_chk
      CHECK (priority BETWEEN -1000 AND 1000);
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Indexes used by the worker and monitoring (idempotent).
CREATE INDEX IF NOT EXISTS idx_jobq_jobs_status_scheduled
  ON jobq.jobs (status, scheduled_at);

CREATE INDEX IF NOT EXISTS idx_jobq_jobs_status_started
  ON jobq.jobs (status, started_at);

-- Correlation-centric index for typical reporting/debug flows.
CREATE INDEX IF NOT EXISTS idx_jobq_jobs_corrid_jobid
  ON jobq.jobs (correlation_id, job_id DESC);

------------------------------
-- 3. updated_at trigger – maintain last modification timestamp
------------------------------

CREATE OR REPLACE FUNCTION jobq.set_timestamp()
RETURNS TRIGGER
LANGUAGE plpgsql
SET search_path = pg_catalog, jobq
AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_jobq_jobs_set_timestamp ON jobq.jobs;

CREATE TRIGGER trg_jobq_jobs_set_timestamp
BEFORE UPDATE ON jobq.jobs
FOR EACH ROW
EXECUTE FUNCTION jobq.set_timestamp();
